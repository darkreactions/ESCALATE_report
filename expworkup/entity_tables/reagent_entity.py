import logging
import numpy as np
import pandas as pd
import logging
import os
import sys

modlog = logging.getLogger('report.reagent_entities')

class ReagentObject:
    modlog = logging.getLogger('report.RegentObject')
    ''' Reagent Object containing template, model and object information

    v1 input is dataframe of the reagent information as parsed from JSON from google drive

    TODO: build reagent_object at the initial parsing of the download JSON file
    TODO: direct import of reagent_model information from Capture
    TODO: consistency checks and validation of reagent_object concentration calculations

    next generation should be closer to a json file structure of the reagent file. Ideally the reagent json itself can
    be provided to a class and then used downstream for additional manipulation
    '''

    def __init__(self,
                 reagent_df,
                 reagent_name):
        """
        initializes ReagentObjects

        TODO: generate class prior to call of concCalc
        TODO: build reagent objects at initial import from JSON structure

        Args:
            reagent_df: dataframe as generated by concCalc
            reagent_name: parsed name of the reagent (ex. '_raw_reagent_1')
        """
        self.conc_v1 = self.calc_conc_v1(reagent_df, reagent_name)


    def calc_conc_v1(self,
                     one_reagent_df,
                     reagent_name):
        """ calculate concentration of each chemical in reagent, return dataframe of chemicals and concentrations

        returns dataframe columns formatted as '_raw_reagent_1_v1-conc_InChIKey', rows are default numbered indexes

        Args:
            one_reagent_df: dataframe as generated by concCalc
            reagent_name: parsed name of the reagent (ex. '_raw_reagent_1')
        """
        conc = {}
        # calculate the total volume of the reagent solution using the volume of the chemicals as an approximation
        for index, row in one_reagent_df.iterrows():
            if row['unit'] == 'gram':
                one_reagent_df.at[index, 'chemical_volume'] = float(row['amount']) / \
                                                              float(row['density'])  # converts grams to mL
            elif row['unit'] == 'milliliter':
                one_reagent_df.at[index, 'chemical_volume'] = row['amount']  # leaves mL well enough alone
            elif row['unit'] == 'null':
                one_reagent_df.at[index, 'chemical_volume'] = 0  # null is null!
        # calculate the concentrations of each chemical using the approximated volume from above
        final_reagent_volume = one_reagent_df['chemical_volume'].astype(float).sum()
        for index, row in one_reagent_df.iterrows():
            if row['unit'] == 'gram':
                calculated_concentration = float(row['amount']) / float(row['molecularmass']) / \
                                                 float(final_reagent_volume / 1000)  # g --> mol --> [M] (v1-conc)
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
            elif row['unit'] == 'milliliter':
                calculated_concentration = float(row['amount']) * float(row['density']) / \
                                            float(row['molecularmass']) / float(final_reagent_volume / 1000)
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
            elif row['unit'] == 'null':
                calculated_concentration = 0  # null is null!
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
        return([conc])


def UID_generator():
    pass

def build_conc_df(df):
    '''
    Takes in perovskite dataframe and returns a list of "first runs" for a given set of reagents.  
    These 'first runs' are often representative of the maximum solubility limits of a given space.  
    Likely there will be some strangeness in the first iteration that requires tuning of these filters.

    Assumptions: 
    1. ommitting reagents 4-5 for "uniqueness" comparison
    2. need to generalize to use experimental volumes to determing which experiments use which reagents
    3. definitely is missing some of the unique reagents (some are performed at various concetnrations, not just hte first)
    
    Filters are explained in code
    '''
    # Only consider runs where the workflow are equal to 1.1 (the ITC method after initial development)
    # TODO: generalize beyond 1.1
    # #remove this once testing is complete and the reagent models / objects are exportable
    df = df[df['_raw_ExpVer'] == 1.1].reset_index(drop=True) # Harded coded to 1.1 for development

    # only reaction that use GBL as a solvent (1:1 comparisons -- DMF and other solvents could convolute analysis)    
    df = df[df['_raw_reagent_0_chemicals_0_InChIKey'] == "YEJRWHAVMIAJKC-UHFFFAOYSA-N"].reset_index(drop=True)    

    # removes some anomalous entries with dimethyl ammonium still listed as the organic.
    #perov = perov[perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    # build a list of all unique combinations of inchi keys for the remaining dataset
    experiment_inchis_df = df.filter(regex='_raw_reagent.*.InChIKey')
    experiment_inchis = (experiment_inchis_df.columns.values)
    experiment_inchis_df = pd.concat([df['name'], experiment_inchis_df], axis=1)
    ignore_list = ['name']

    df.set_index('name', inplace=True)

    # clean up blanks, and bad entries for inchikeys, return date sorted df
    experiment_inchis_df.replace(0.0, np.nan, inplace=True)
    experiment_inchis_df.replace(str(0), np.nan, inplace=True)
    experiment_inchis_df.set_index('name', inplace=True)
    experiment_inchis_df.sort_index(axis=0, inplace=True)

    # find extra reagents (not present in any initial testing runs) (i.e. experiments with zeroindex-reagents 2 < x > 5)
    secondary_reagent_columns = []
    for column in experiment_inchis_df.columns:
        if column in ignore_list:
            pass
        else:
            reagent_num = int(column.split("_")[3]) # 3 is the value of the split for reagent num
            if reagent_num > 10 and reagent_num < 11:
                secondary_reagent_columns.append(column)
    experiment_inchis_df.drop(secondary_reagent_columns, axis=1, inplace=True) 
    experiment_inchis_df.drop_duplicates(inplace=True)
#    experiment_inchis_df = pd.concat([df, experiment_inchis_df], axis=1, join='inner')
    experiment_inchis_df['name'] = experiment_inchis_df.index

    # get the concentration of the relevant associated inchi keys for all included reageagents

    def get_chemical_conc(reagent, inchi, index):
        reagent_inorg_header = f'_raw_reagent_{reagent}_v1-conc_{inchi}'
        try:
            inorg_conc = df.loc[index, reagent_inorg_header]
        except:
            inorg_conc = 0
        return inorg_conc
    
    prototype_df = experiment_inchis_df.copy()
    for column in experiment_inchis_df.columns:
        if column in ignore_list:
            pass
        else:
            column_name_split = column.split("_")
            new_column_name = '_'.join(column_name_split[:6]) + '_v1conc'
            reagent_num = column.split("_")[3]
            prototype_df[new_column_name] = experiment_inchis_df.apply(lambda x: get_chemical_conc(reagent_num, x[column], x['name']), axis=1)
    prototype_df = pd.concat([df['_rxn_organic-inchikey'], prototype_df], axis=1, join='inner')
    return prototype_df


def get_tray_set(perovskite_df):
    '''
    inputs the perovskite dataset and returns a list of UIDs associated with all unique compound ingredient objects 

    uses the combination of the tray uid and the organic inchi-key to determine if the 
    reagent preparation is unique.  Assumption is that the organic labeling in def namecleaner of report is accurate
    will need to be extended to account for variations in inorganic, solvent, etc. 
    TODO: Extend beyond wf 1.1 assumptions
    TODO: Generate equivalent for models (not just the reagent objects)
    
    :param perovskite_df: generated perovskite dataset using ESCALATE_report v0.8.1
    :return: tray_uids associated with unique compound ingredient objects in the dataset (see assumptions)
    '''

    rxn_uids = perovskite_df['name'].tolist()
    inchi_list = perovskite_df['_rxn_organic-inchikey'].tolist()

    tray_uids = {}
    zipped_reagentpreps = zip(rxn_uids, inchi_list)

    for uid_inchi in zipped_reagentpreps:
        experiment_uid = uid_inchi[0]
        inchi = uid_inchi[1]
        tray_uid = experiment_uid.rsplit('_', 1)[0]

        # If combined value of UID and 
        tray_uids[f'{tray_uid}_{inchi}'] = experiment_uid
    return(tray_uids)


def get_unique_volumes(unique_df):
    '''
    Get the volume amounts from the downselected unique reagent preparations
    '''

    volume_columns = [column for column in unique_df if 'volume' in column]

    # Remove columns we don't want in the 
    volume_columns = [x for x in volume_columns if 'units' not in x]
    volume_columns = [x for x in volume_columns if 'instructions' in x]
    volume_columns.extend(['name','_rxn_organic-inchikey'])

    vol_df = unique_df[volume_columns]

    return vol_df


def get_reagent_amounts(unique_df, nominal=False):
    '''
    gather up all reagent preparation infomation and return indexed df

    '''
    actuals_columns = [column for column in unique_df if '_raw_reagent_' in column and '_chemicals_' in column and '_actual_amount' in column]
    nominals_columns = [column for column in unique_df if '_raw_reagent_' in column and '_chemicals_' in column and '_nominal_amount' in column]

    if nominal == True:
        nominal_df = unique_df[nominals_columns]
        return nominal_df
    else:
        actuals_df = unique_df[actuals_columns]
        return actuals_df

def export_reagent_objects(perovskite_df, target_naming_scheme):
    '''
    Exports a csv table of all reagent object data
    
    :param 

    '''
    all_unique_compounds_uids = get_tray_set(perovskite_df)

    unique_df = perovskite_df.loc[perovskite_df['name'].isin(all_unique_compounds_uids.values())]
    print(unique_df.shape)

    reagent_volumes_df = get_unique_volumes(unique_df)
    reagent_amounts_df = get_reagent_amounts(unique_df) # default is to return the actuals (nominals can be toggled)

    vols_amounts_df = pd.concat([reagent_volumes_df,reagent_amounts_df], axis=1)
    object_out_name = f'{target_naming_scheme}_objects.csv'
    vols_amounts_df.to_csv(object_out_name)
    return object_out_name

def all_unique_ingredients(perovskite_df, target_naming_scheme, chem_df):
    '''
    Reads in most recent perovskite dataframe and returns dictionary 
    of structure {organic_inchi: {(Chemical-Inchi, Chemical-Name, concentration) x 3}} 
    one nested dictionary for each inorganic, organic-1, and organic-2
    WARNING: Functionality currently restricted to wf 1.1 export and processing

    :param perovskite_csv: perovskite dataframe generated using version 0.82 of the report code

    '''
    conc_df = build_conc_df(perovskite_df) 
    conc_df.fillna(value='null', inplace=True)

    #call functions to export objects and models
    reagent_objects_file = export_reagent_objects(perovskite_df, target_naming_scheme)
    modlog.info(f'Generated compound ingredient (reagents) objects in {reagent_objects_file}')
    


    # Setup the chemical dataframe for reading out chemical names (specific for 1.1)
    # TODO: generalize beyond 1.1 for direct reaction reproductions from reagent objects / models
    conc_dict_out = {}
    chem_df = chem_df.fillna('null') #insert our choice placeholder for blank values --> 'null'
    chem_df.set_index('InChI Key (ID)', inplace=True)

    for exp_uid, row in conc_df.iterrows():
        conc_dict_out[exp_uid] = {}
        conc_dict_out[exp_uid]['chemical_info'] = {}
        conc_dict_out[exp_uid]['chemical_info']['solvent'] = (conc_df.loc[exp_uid,'_raw_reagent_0_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_0_chemicals_0_InChIKey'],"Chemical Name"]
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['inorganic'] = (conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['organic-1'] = (conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['organic-2'] = (conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['organic_inchi'] = conc_df.loc[exp_uid, '_rxn_organic-inchikey']
    return conc_dict_out

# Section 2
## The following function normalizes differences in the state space concentrations
## and sets all of the axes to the same scale. This might allow for a different overlaying 
## of various state spaces

def _compute_proportional_conc(perovRow, v1=True, chemtype='organic'):
    """Compute the concentration of acid, inorganic, or acid for a given row of a crank dataset
    TODO: most of this works, just need to test before deploy
    
    Intended to be pd.DataFrame.applied over the rows of a crank dataset
    
    :param perovRow: a row of the crank dataset
    :param v1: use v1 concentration or v0 
    :param chemtype: in ['organic', 'inorganic', 'acid']
    
    
    Currently hard codes inorganic as PbI2 and acid as FAH. TODO: generalize
    """
    inchis = {
        'organic': perovRow['_rxn_organic-inchikey'],
        # Inorganic assumes PbI2, so far the only inorganic in the dataset
        'inorganic': 'RQQRAHKHDFPBMC-UHFFFAOYSA-L',
        ## acid assumes FAH (as of writing this the only one in the dataset)
        'acid': 'BDAGIHXWWSANSR-UHFFFAOYSA-N'
    }
    speciesExperimentConc = perovRow[f"{'_rxn_M_' if v1 else '_rxn_v0-M_'}{chemtype}"]
    
    reagentConcPattern = f"_raw_reagent_[0-9]_{'v1-' if v1 else ''}conc_{inchis[chemtype]}"
    speciesReagentConc = perovRow.filter(regex=reagentConcPattern)
    
    if speciesExperimentConc == 0: 
        return speciesExperimentConc
    else: 
        return speciesExperimentConc / np.max(speciesReagentConc)

def _prepare(shuffle=0, deep_shuffle=0):
    ''' reads in perovskite dataframe and returns only experiments that meet specific criteria

    --> Data preparation occurs here
    criteria for main dataset include experiment version 1.1 (workflow 1 second generation), only
    reactions that use GBL, and 
    '''
    perov = pd.read_csv(os.path.join(VERSION_DATA_PATH, CRANK_FILE), skiprows=4, low_memory=False)
    perov = perov[perov['_raw_ExpVer'] == 1.1].reset_index(drop=True)

    # only reaction that use GBL as a solvent (1:1 comparisons -- DMF and other solvents could convolute analysis)    
    perov = perov[perov['_raw_reagent_0_chemicals_0_InChIKey'] == "YEJRWHAVMIAJKC-UHFFFAOYSA-N"].reset_index(drop=True)    

    # removes some anomalous entries with dimethyl ammonium still listed as the organic.
    perov = perov[perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    #We need to know which reactions have no succes and which have some
    organickeys = perov['_rxn_organic-inchikey']
    uniquekeys = organickeys.unique()

    df_key_dict = {}
    #find an remove all organics with no successes (See SI for reasoning)
    for key in uniquekeys:
        #build a dataframe name by the first 10 characters of the inchi containing all rows with that inchi
        df_key_dict[str(key)] = perov[perov['_rxn_organic-inchikey'] == key]
    all_groups = []
    successful_groups = []
    failed_groups = []
    for key, value in df_key_dict.items():
        all_groups.append(key)
        if 4 in value['_out_crystalscore'].values.astype(int):
            successful_groups.append(key)
        else:
            failed_groups.append(key)

    #only grab reactions where there were some recorded successes in the amine grouping
    successful_perov = (perov[perov['_rxn_organic-inchikey'].isin(successful_groups)])
    successful_perov = successful_perov[successful_perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    # we need to do this so we can drop nans and such while keeping the data consistent
    # we couldnt do this on the full perov data since dropna() would nuke the entire dataset (rip)
    all_columns = successful_perov.columns
    
    full_data = successful_perov[all_columns].reset_index(drop=True)

    full_data = full_data.fillna(0).reset_index(drop=True)
    successful_perov = full_data[full_data['_out_crystalscore'] != 0].reset_index(drop=True)
    
    ## Shuffle options for these unique runs
    out_hold = pd.DataFrame()
    out_hold['out_crystalscore'] = successful_perov['_out_crystalscore']
    if shuffle == 1:
        out_hold['out_crystalscore'] = successful_perov['_out_crystalscore']
        successful_perov = successful_perov.reindex(np.random.permutation(successful_perov.index)).reset_index(drop=True)
        successful_perov['_out_crystalscore'] = out_hold['out_crystalscore']
    if deep_shuffle == 1:
        # Only want to shuffle particular columns (some shuffles will break processing), we will attempt to describe each selection in text

        #build holdout (not shuffled)
        out_hold_deep_df = pd.DataFrame()
        out_hold_deep_df = successful_perov.loc[:, '_raw_model_predicted':'_prototype_heteroatomINT']
        out_hold_deep_df = pd.concat([successful_perov['_rxn_organic-inchikey'], out_hold_deep_df], axis=1) 

        #isolate shuffle set
        shuffle_deep_df = pd.DataFrame()
        shuffle_deep_df = pd.concat([successful_perov.loc[:, 'name':'_rxn_M_organic'], 
                                     successful_perov.loc[:, '_rxn_temperatureC_actual_bulk' : '_feat_Hacceptorcount']], 
                                     axis = 1)
        successful_perov = shuffle_deep_df.apply(np.random.permutation)

        successful_perov.reset_index(drop=True)
        successful_perov = pd.concat([out_hold_deep_df, successful_perov], axis=1)

    successful_perov.rename(columns={"_raw_v0-M_acid": "_rxn_v0-M_acid", "_raw_v0-M_inorganic": "_rxn_v0-M_inorganic", "_raw_v0-M_organic":"_rxn_v0-M_organic"}, inplace=True)

    return successful_perov




