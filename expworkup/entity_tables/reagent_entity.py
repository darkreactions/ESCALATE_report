import logging
import numpy as np
import pandas as pd
import logging
import os
import sys

from utils import globals
from expworkup import devconfig as config
from utils.globals import lab_safeget
from utils.file_handling import get_experimental_run_lab


modlog = logging.getLogger(__name__)

class ReagentObject:
    modlog = logging.getLogger('report.RegentObject')
    ''' Reagent Object containing template, model and object information

    v1 input is dataframe of the reagent information as parsed from JSON from google drive

    TODO: direct import of reagent_model information from Capture
    TODO: consistency checks and validation of reagent_object concentration calculations
    '''

    def __init__(self,
                 reagent_df,
                 reagent_name):
        """
        initializes ReagentObjects

        TODO: generate class prior to call of concCalc
        TODO: build reagent objects at initial import from JSON structure

        Args:
            reagent_df: dataframe as generated by concCalc
            reagent_name: parsed name of the reagent (ex. '_raw_reagent_1')
        """
        self.conc_v1 = self.calc_conc_v1(reagent_df, reagent_name)


    def calc_conc_v1(self,
                     one_reagent_df,
                     reagent_name):
        """ calculate concentration of each chemical in reagent, return dataframe of chemicals and concentrations

        returns dictionary with keys formatted as '_raw_reagent_1_v1-conc_InChIKey', rows are default numbered indexes

        :param one_reagent_df: dataframe as generated by concCalc (example below of reagent input)
                                      name                     InChiKey  density   m_type molecularmass amount        unit
            0                Lead Diiodide  RQQRAHKHDFPBMC-UHFFFAOYSA-L     6.16    inorg        461.01   5.12        gram
            1  Di-isopropylammonium iodide  PBGZCCFVBVEIAS-UHFFFAOYSA-N  1.45427      org         229.1   1.22        gram
            2          Gamma-Butyrolactone  YEJRWHAVMIAJKC-UHFFFAOYSA-N     1.12  solvent         86.09     11  milliliter
            3                         null                         null     null     null          null   null        null
        :param reagent_name: parsed name of the reagent (ex. '_raw_reagent_1')
        :return: 
        """
        conc = {}
        # calculate the total volume of the reagent solution using the volume of the chemicals as an approximation
        for index, row in one_reagent_df.iterrows():
            if row['unit'] == 'gram':
                one_reagent_df.at[index, 'chemical_volume'] = float(row['amount']) / \
                                                              float(row['density'])  # converts grams to mL
            elif row['unit'] == 'milliliter':
                one_reagent_df.at[index, 'chemical_volume'] = row['amount']  # leaves mL well enough alone
            elif row['unit'] == 'null':
                one_reagent_df.at[index, 'chemical_volume'] = 0  # null is null!
        # calculate the concentrations of each chemical using the approximated volume from above
        final_reagent_volume = one_reagent_df['chemical_volume'].astype(float).sum()
        for index, row in one_reagent_df.iterrows():
            if row['unit'] == 'gram':
                calculated_concentration = float(row['amount']) / float(row['molecularmass']) / \
                                                 float(final_reagent_volume / 1000)  # g --> mol --> [M] (v1-conc)
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
            elif row['unit'] == 'milliliter':
                calculated_concentration = float(row['amount']) * float(row['density']) / \
                                            float(row['molecularmass']) / float(final_reagent_volume / 1000)
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
            elif row['unit'] == 'null':
                calculated_concentration = 0  # null is null!
                name_space = (reagent_name + "_v1-conc_" + (one_reagent_df.loc[(index, 'InChiKey')]))
                conc[name_space] = calculated_concentration
        return([conc])


def UID_generator():
    pass

def build_conc_df(df):
    '''
    Takes in perovskite dataframe and returns a list of "first runs" for a given set of reagents.  
    These 'first runs' are often representative of the maximum solubility limits of a given space.  
    Likely there will be some strangeness in the first iteration that requires tuning of these filters.

    Assumptions: 
    1. ommitting reagents 4-5 for "uniqueness" comparison
    2. need to generalize to use experimental volumes to determing which experiments use which reagents
    3. definitely is missing some of the unique reagents (some are performed at various concetnrations, not just hte first)
    
    Filters are explained in code
    '''
    # Only consider runs where the workflow are equal to 1.1 (the ITC method after initial development)
    # TODO: generalize beyond 1.1
    # #remove this once testing is complete and the reagent nominals / objects are exportable
    df = df[df['_raw_ExpVer'] == 1.1].reset_index(drop=True) # Harded coded to 1.1 for development

    # removes some anomalous entries with dimethyl ammonium still listed as the organic.
    #perov = perov[perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    # build a list of all unique combinations of inchi keys for the remaining dataset
    experiment_inchis_df = df.filter(regex='_raw_reagent.*.InChIKey')
    experiment_inchis = (experiment_inchis_df.columns.values)
    experiment_inchis_df = pd.concat([df['name'], experiment_inchis_df], axis=1)
    ignore_list = ['name']

    df.set_index('name', inplace=True)

    # clean up blanks, and bad entries for inchikeys, return date sorted df
    experiment_inchis_df.replace(0.0, np.nan, inplace=True)
    experiment_inchis_df.replace(str(0), np.nan, inplace=True)
    experiment_inchis_df.set_index('name', inplace=True)
    experiment_inchis_df.sort_index(axis=0, inplace=True)

    # find extra reagents (not present in any initial testing runs) (i.e. experiments with zeroindex-reagents 2 < x > 5)
    secondary_reagent_columns = []
    for column in experiment_inchis_df.columns:
        if column in ignore_list:
            pass
        else:
            reagent_num = int(column.split("_")[3]) # 3 is the value of the split for reagent num
            if reagent_num > 10 and reagent_num < 11:
                secondary_reagent_columns.append(column)
    experiment_inchis_df.drop(secondary_reagent_columns, axis=1, inplace=True) 
    experiment_inchis_df.drop_duplicates(inplace=True)
#    experiment_inchis_df = pd.concat([df, experiment_inchis_df], axis=1, join='inner')
    experiment_inchis_df['name'] = experiment_inchis_df.index

    # get the concentration of the relevant associated inchi keys for all included reageagents

    def get_chemical_conc(reagent, inchi, index):
        reagent_inorg_header = f'_raw_reagent_{reagent}_v1-conc_{inchi}'
        try:
            inorg_conc = df.loc[index, reagent_inorg_header]
        except:
            inorg_conc = 0
        return inorg_conc
    
    prototype_df = experiment_inchis_df.copy()
    for column in experiment_inchis_df.columns:
        if column in ignore_list:
            pass
        else:
            column_name_split = column.split("_")
            new_column_name = '_'.join(column_name_split[:6]) + '_v1conc'
            reagent_num = column.split("_")[3]
            prototype_df[new_column_name] = experiment_inchis_df.apply(lambda x: get_chemical_conc(reagent_num, x[column], x['name']), axis=1)
    prototype_df = pd.concat([df['_rxn_organic-inchikey'], prototype_df], axis=1, join='inner')
    return prototype_df


def get_tray_uids(perovskite_df):
    '''
    inputs the perovskite dataset and returns a list of UIDs associated 
    with all unique compound ingredient objects 

    :param perovskite_df: generated perovskite dataset using 
    ESCALATE_report v0.8.1

    :return: an instance of every unique set experiments in the dataset
    '''
    all_uids = perovskite_df['name'].tolist()

    tray_uids = []
    exp_tray_dict = {}
    for experiment_uid in all_uids:
        tray_uid = experiment_uid.rsplit('_', 1)[0]
        tray_uids.append(tray_uid)
        exp_tray_dict[tray_uid] = experiment_uid
    tray_uids = set(tray_uids)

    representative_experiments = []
    for tray_uid in tray_uids:
        representative_experiments.append(exp_tray_dict[tray_uid])

    return(representative_experiments)


def get_reagent_df(perovskite_df, nominal=False):
    '''
    gather up all reagent preparation infomation and return df of 
    reagent entities indexed by uid

    :param perovskite_df: dataframe rendered by escalate_report v0.8.1
    :param nominal: generated the dataframe using the nominal amounts (default uses actuals)

    :return: dataframe of all unique reagents used in the campaign (all unique
    from the dataset perovskite_df)
    '''
    # Len of all_chem_inchis should be reagents *max chemical from report (e.g. 9 reagents * 4 chemicals = 36)
    selected_columns = []

    all_chem_inchis = [x for x in perovskite_df.columns if '_raw_reagent_' in x \
                  and 'chemicals' in x \
                  and 'InChIKey' in x]
    selected_columns.extend(all_chem_inchis)

    # reads in all of the recorded volume observations (SOlution observations)
    recorded_volumes = [x for x in perovskite_df.columns if '_raw_reagent_' in x \
                        and 'instructions' in x \
                        and 'volume' in x]
    selected_columns.extend(recorded_volumes)

    all_amounts =  [x for x in perovskite_df.columns if '_raw_reagent_' in x \
                    and 'chemicals' in x \
                    and 'amount' in x]

    if nominal == True:
        # down select to nominals
        all_amounts_curated = [x for x in all_amounts if 'nominal' in x]
        selected_columns.extend(all_amounts_curated)
    else:
        # gets what was actually done
        all_amounts_curated = [x for x in all_amounts if 'actual' in x]
        selected_columns.extend(all_amounts_curated)

    selected_columns.append('name')
    representative_tray_uids = get_tray_uids(perovskite_df)
    reagent_details_df = perovskite_df[perovskite_df['name'].isin(representative_tray_uids)]
    reagent_details_df = reagent_details_df[selected_columns]
    return reagent_details_df


def curate_reagent_objects(reagent_details_df, nominal=False, export_observables=False):
    '''
    for each uid and each reagent build a dictionary with keys equal to the inchikeys and value strings (ordered)
    for the time being these omit unique actions to the definitions
    
    :param reagent_details_df: all columns of reagent descriptions exported by escalate_report v0.8.1
    :return: dataframe consisting of every unique reagent (precursor / compound ingredient) used in the dataset
    '''
    reagent_count = 0
    restructured_reagents_df = pd.DataFrame()

    actual = 'actual'
    if nominal is True:
        actual = 'nominal'

    #TODO: dataset general hangling, not based on laboratory information etc
    maxreagentchemicals = lab_safeget(config.lab_vars, globals.get_lab(), 'maxreagentchemicals')
    while reagent_count < lab_safeget(config.lab_vars, globals.get_lab(), 'max_reagents'):
        reagent_amounts_df = (reagent_details_df.loc[:,f'_raw_reagent_{str(reagent_count)}_chemicals_0_{actual}_amount':\
                                                 f'_raw_reagent_{str(reagent_count)}_chemicals_{str(maxreagentchemicals-1)}_{actual}_amount_units'])
        reagent_inchis_df = (reagent_details_df.loc[:,f'_raw_reagent_{str(reagent_count)}_chemicals_0_InChIKey':\
                                                f'_raw_reagent_{str(reagent_count)}_chemicals_{str(maxreagentchemicals-1)}_InChIKey'])
        single_reagent_df = pd.concat([reagent_amounts_df, reagent_inchis_df], axis=1)
        single_reagent_df.fillna(0, inplace=True)
        if export_observables is True: 
            observations_df = reagent_details_df[[f'_raw_reagent_{str(reagent_count)}_instructions_2_volume']]
            single_reagent_df = pd.concat([single_reagent_df, observations_df], axis=1)

        new_headers = []
        for header in single_reagent_df.columns.tolist():
            new_header = header.split('_', 4)[4]
            new_headers.append(new_header)

            #add reagent name to keep track of UIDs
            uid_reagent_nlist = header.split('_', 4)
            s = '_'
            uid_rname = s.join(uid_reagent_nlist[2:4])


        single_reagent_df.columns = new_headers
        updated_name_column = {'name': reagent_details_df['name'].transform(lambda x: str((x.rsplit('_', 1)[0])))}

        updated_name_column = pd.DataFrame(updated_name_column)
        updated_name_column['ingredient_uid_name'] = updated_name_column['name'].astype(str) + '_' + uid_rname

        single_reagent_df = pd.concat([updated_name_column['ingredient_uid_name'], single_reagent_df, reagent_details_df['name']], axis=1)

        restructured_reagents_df = pd.concat([single_reagent_df, restructured_reagents_df], axis=0)
        reagent_count+=1

    # Drop all rows which the sum of total amounts is equal to zero (i.e. there was nothing reported for that reagent)
    modlog.info(f'Rendering reagent "{actual}" dataframe with shape {restructured_reagents_df.shape} prior to filtering')
    restructured_reagents_df = restructured_reagents_df[restructured_reagents_df[new_headers].sum(axis=1) != 0]
    modlog.info(f'Removing blank reagents results in {restructured_reagents_df.shape}')

    if nominal is True:
        # drop all things that share included variables in v0.8.1  this is only the amounts of chemicals
        #TODO: uncover the true meaning of uniqueness in regards to "nominals" --> what makes something a model
        # Should use the reagent class to do diffs against existing reagents.
        restructured_reagents_df.drop_duplicates(subset=new_headers, inplace=True)
        modlog.info(f'Removing duplicate preps reagents results in {restructured_reagents_df.shape}')

    restructured_reagents_df.drop_duplicates(inplace=True)
    modlog.info(f'Removing complete duplicates results in {restructured_reagents_df.shape}')
    restructured_reagents_df.fillna('null', inplace=True)

    return restructured_reagents_df

def export_reagent_objects(perovskite_df, target_naming_scheme, nominal=False, export_observables=False):
    '''
    Exports a csv table of all reagent object or model data
    
    :param perovskite_df: report generated data frame from v0.81
    :param target_naming_scheme: desired output file name for objects dataframe
    :param nominal: (bool) if true ideally (#TODO: define model by the ratio of various components in solution) else
    define object by every unique instance
    :param export_observables: (bool) if true bring along all of the observations about reagent prep (instructions in headers)

    :return: outfile name for logging also for targeting csv file
    '''
    reagent_details_df = get_reagent_df(perovskite_df, nominal=nominal)# default is to return the actuals (nominals can be toggled)
    reagent_objects_df = curate_reagent_objects(reagent_details_df, nominal=nominal, export_observables=export_observables)
        
    if nominal is False:
        out_name = f'{target_naming_scheme}_objects.csv'

    elif nominal is True:
        out_name = f'{target_naming_scheme}_nominals.csv'
    
    reagent_objects_df.to_csv(out_name)

    return out_name

def all_unique_ingredients(perovskite_df, target_naming_scheme, chemdf_dict, export_observables=False):
    '''
    Reads in most recent perovskite dataframe and returns dictionary 
    of structure {organic_inchi: {(Chemical-Inchi, Chemical-Name, concentration) x 3}} 
    one nested dictionary for each inorganic, organic-1, and organic-2
    WARNING: Functionality currently restricted to wf 1.1 export and processing

    :param perovskite_csv: perovskite dataframe generated using version 0.82 of the report code

    '''
    conc_df = build_conc_df(perovskite_df) 
    conc_df.fillna(value='null', inplace=True)

    #call functions to export objects and nominals
    reagent_objects_file = export_reagent_objects(perovskite_df, target_naming_scheme, nominal=False, export_observables=export_observables)

    reagent_nominal_file = export_reagent_objects(perovskite_df, target_naming_scheme, nominal=True)


    modlog.info(f'Generated compound ingredient (reagents) objects in {reagent_objects_file}')
    modlog.info(f'Generated compound ingredient (reagents) nominals in {reagent_nominal_file}')
    

    # Setup the chemical dataframe for reading out chemical names (specific for 1.1)
    # TODO: generalize beyond 1.1 for direct reaction reproductions from reagent objects --> to models (harder, hypothesis)
    conc_dict_out = {}

    for exp_uid, row in conc_df.iterrows():
        conc_dict_out[exp_uid] = {}
        chem_df = chemdf_dict[get_experimental_run_lab(exp_uid)]
        chem_df = chem_df.fillna('null') #insert our choice placeholder for blank values --> 'null'
        conc_dict_out[exp_uid]['chemical_info'] = {}
        conc_dict_out[exp_uid]['chemical_info']['solvent'] = (conc_df.loc[exp_uid,'_raw_reagent_0_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_0_chemicals_0_InChIKey'],"Chemical Name"]
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['inorganic'] = (conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_0_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['organic-1'] = (conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_1_chemicals_1_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['chemical_info']['organic-2'] = (conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_InChIKey'], 
                                                            chem_df.loc[conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_InChIKey'],"Chemical Name"],
                                                            conc_df.loc[exp_uid,'_raw_reagent_2_chemicals_0_v1conc']                                                               
                                                            ) 
        conc_dict_out[exp_uid]['organic_inchi'] = conc_df.loc[exp_uid, '_rxn_organic-inchikey']
    return conc_dict_out

# Section 2
## The following function normalizes differences in the state space concentrations
## and sets all of the axes to the same scale. This might allow for a different overlaying 
## of various state spaces

def _compute_proportional_conc(perovRow, v1=True, chemtype='organic'):
    """Compute the concentration of acid, inorganic, or acid for a given row of a crank dataset
    TODO: most of this works, just need to test before deploy
    
    Intended to be pd.DataFrame.applied over the rows of a crank dataset
    
    :param perovRow: a row of the crank dataset
    :param v1: use v1 concentration or v0 
    :param chemtype: in ['organic', 'inorganic', 'acid']
    
    
    Currently hard codes inorganic as PbI2 and acid as FAH. TODO: generalize
    """
    inchis = {
        'organic': perovRow['_rxn_organic-inchikey'],
        # Inorganic assumes PbI2, so far the only inorganic in the dataset
        'inorganic': 'RQQRAHKHDFPBMC-UHFFFAOYSA-L',
        ## acid assumes FAH (as of writing this the only one in the dataset)
        'acid': 'BDAGIHXWWSANSR-UHFFFAOYSA-N'
    }
    speciesExperimentConc = perovRow[f"{'_rxn_M_' if v1 else '_rxn_v0-M_'}{chemtype}"]
    
    reagentConcPattern = f"_raw_reagent_[0-9]_{'v1-' if v1 else ''}conc_{inchis[chemtype]}"
    speciesReagentConc = perovRow.filter(regex=reagentConcPattern)
    
    if speciesExperimentConc == 0: 
        return speciesExperimentConc
    else: 
        return speciesExperimentConc / np.max(speciesReagentConc)

def _prepare(shuffle=0, deep_shuffle=0):
    ''' reads in perovskite dataframe and returns only experiments that meet specific criteria

    --> Data preparation occurs here
    criteria for main dataset include experiment version 1.1 (workflow 1 second generation), only
    reactions that use GBL, and 
    '''
    perov = pd.read_csv(os.path.join(VERSION_DATA_PATH, CRANK_FILE), skiprows=4, low_memory=False)
    perov = perov[perov['_raw_ExpVer'] == 1.1].reset_index(drop=True)

    # only reaction that use GBL as a solvent (1:1 comparisons -- DMF and other solvents could convolute analysis)    
    perov = perov[perov['_raw_reagent_0_chemicals_0_InChIKey'] == "YEJRWHAVMIAJKC-UHFFFAOYSA-N"].reset_index(drop=True)    

    # removes some anomalous entries with dimethyl ammonium still listed as the organic.
    perov = perov[perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    #We need to know which reactions have no succes and which have some
    organickeys = perov['_rxn_organic-inchikey']
    uniquekeys = organickeys.unique()

    df_key_dict = {}
    #find an remove all organics with no successes (See SI for reasoning)
    for key in uniquekeys:
        #build a dataframe name by the first 10 characters of the inchi containing all rows with that inchi
        df_key_dict[str(key)] = perov[perov['_rxn_organic-inchikey'] == key]
    all_groups = []
    successful_groups = []
    failed_groups = []
    for key, value in df_key_dict.items():
        all_groups.append(key)
        if 4 in value['_out_crystalscore'].values.astype(int):
            successful_groups.append(key)
        else:
            failed_groups.append(key)

    #only grab reactions where there were some recorded successes in the amine grouping
    successful_perov = (perov[perov['_rxn_organic-inchikey'].isin(successful_groups)])
    successful_perov = successful_perov[successful_perov['_rxn_organic-inchikey'] != 'JMXLWMIFDJCGBV-UHFFFAOYSA-N'].reset_index(drop=True)

    # we need to do this so we can drop nans and such while keeping the data consistent
    # we couldnt do this on the full perov data since dropna() would nuke the entire dataset (rip)
    all_columns = successful_perov.columns
    
    full_data = successful_perov[all_columns].reset_index(drop=True)

    full_data = full_data.fillna(0).reset_index(drop=True)
    successful_perov = full_data[full_data['_out_crystalscore'] != 0].reset_index(drop=True)
    
    ## Shuffle options for these unique runs
    out_hold = pd.DataFrame()
    out_hold['out_crystalscore'] = successful_perov['_out_crystalscore']
    if shuffle == 1:
        out_hold['out_crystalscore'] = successful_perov['_out_crystalscore']
        successful_perov = successful_perov.reindex(np.random.permutation(successful_perov.index)).reset_index(drop=True)
        successful_perov['_out_crystalscore'] = out_hold['out_crystalscore']
    if deep_shuffle == 1:
        # Only want to shuffle particular columns (some shuffles will break processing), we will attempt to describe each selection in text

        #build holdout (not shuffled)
        out_hold_deep_df = pd.DataFrame()
        out_hold_deep_df = successful_perov.loc[:, '_raw_model_predicted':'_prototype_heteroatomINT']
        out_hold_deep_df = pd.concat([successful_perov['_rxn_organic-inchikey'], out_hold_deep_df], axis=1) 

        #isolate shuffle set
        shuffle_deep_df = pd.DataFrame()
        shuffle_deep_df = pd.concat([successful_perov.loc[:, 'name':'_rxn_M_organic'], 
                                     successful_perov.loc[:, '_rxn_temperatureC_actual_bulk' : '_feat_Hacceptorcount']], 
                                     axis = 1)
        successful_perov = shuffle_deep_df.apply(np.random.permutation)

        successful_perov.reset_index(drop=True)
        successful_perov = pd.concat([out_hold_deep_df, successful_perov], axis=1)

    successful_perov.rename(columns={"_raw_v0-M_acid": "_rxn_v0-M_acid", "_raw_v0-M_inorganic": "_rxn_v0-M_inorganic", "_raw_v0-M_organic":"_rxn_v0-M_organic"}, inplace=True)

    return successful_perov




